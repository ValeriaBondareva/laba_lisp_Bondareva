(defun fi (i)
  (labels ((f (k)
             (cond ((= k 1) 1d0)
                   ((= k 11) 1d0)
                   ((and (>= k 2) (<= k 10)) (* (cos (f (1- k))) (sqrt k)))
                   ((and (>= k 12) (<= k 20)) (* (sin (f (1- k))) (sqrt k)))
                   (t (error "i out of range: ~A" k)))))
    (f i)))

(defun table-rec ()
  (append
   (loop for i from 2 to 10 collect (cons i (fi i)))
   (loop for i from 12 to 20 collect (cons i (fi i)))))

(defun table-iter ()
  (let ((res '()) (p 1d0))
    (loop for i from 2 to 10 do
          (setf p (* (cos p) (sqrt i)))
          (push (cons i p) res))
    (setf p 1d0)
    (loop for i from 12 to 20 do
          (setf p (* (sin p) (sqrt i)))
          (push (cons i p) res))
    (nreverse res)))

(defun print-fi-table (&optional (pairs (table-iter)))
  (format t "~&  i |       Fi~%")
  (format t "----+--------------~%")
  (dolist (p pairs)
    (format t "~3D | ~,5,2E~%" (car p) (cdr p)))
  (values))

(defun run-checks ()
  (labels ((abs<= (x b) (<= (abs x) (+ b 1d-12))))
    (let* ((tbl (table-iter))
           (equal-p (equal (mapcar #'cdr tbl) (mapcar #'cdr (table-rec))))
           (ok1 (= (fi 1) 1d0))
           (ok11 (= (fi 11) 1d0))
           (bounds-up   (every #'identity
                               (mapcar (lambda (pr) (abs<= (cdr pr) (sqrt (car pr))))
                                       (remove-if-not (lambda (pr) (<= 2 (car pr) 10)) tbl))))
           (bounds-down (every #'identity
                               (mapcar (lambda (pr) (abs<= (cdr pr) (sqrt (car pr))))
                                       (remove-if-not (lambda (pr) (<= 12 (car pr) 20)) tbl)))))
      (format t "~&[TEST] F1=1: ~A~%" ok1)
      (format t "[TEST] F11=1: ~A~%" ok11)
      (format t "[TEST] rec==iter tables: ~A~%" equal-p)
      (format t "[TEST] |Fi| for 2..10: ~A~%" bounds-up)
      (format t "[TEST] |Fi| for 12..20: ~A~%" bounds-down)
      (values))))
